#!/usr/bin/env python
"""
For documentation, check docs/index.rst
"""

import os, sys
from math import log10
import argparse
import warnings
warnings.filterwarnings("ignore")

def parse_outs(outs_str):
    outs = []
    for par in outs_str.split(','):
        if '-' in par:
            splits = [int(i) for i in par.split('-')]
            if len(splits) == 2:
                outi, outf = splits
                outs += list(range(outi, outf + 1))
            elif len(splits) == 3:
                outi, outf, diff = splits
                outs += list(range(outi, outf + 1, diff))
        else:
            outs += [int(par)]
    return outs

def get_args():
    args = argparse.ArgumentParser(description=("""
A program to efficiently make slices/projections plots of a RAMSES simualtion. 

Quick examples:
>>> plot_projection ..
>>> plot_projection . 10-20 z -t figures
>>> plot_projection . 10-20 x,y -t figures -c 0.6,0.6,0.6 -w 10,pc \
-f den,temp -k slc --sink --den-zlim 1e4 1e10 --T-zlim 10 1e4
"""),
        formatter_class=argparse.RawTextHelpFormatter)
    args.add_argument("jobdir", nargs="?", default="..",
                      help="(Default '..') Path to the simulation directory")
    args.add_argument("outs",  nargs="?", default="all",
                      help="(Default 'all') Output frames. If 'all', do all "
                           "output frames. "
                      "Examples: '10', '10,11,13', '10-20', '10-20-2'")
    args.add_argument("axes", nargs="?", default="x,y,z",
                      help="(Default 'x,y,z') The line of sight. Examples: "
                           "'x', 'x,y,z'")
    args.add_argument("-c", "--center", default='c',
                      help="(Default 'c') The center.\n"
                      "Cases:\n"
                      "    'c': = [0.5, 0.5, 0.5]\n"
                      "    x,y,z: position in boxlen unit, e.g. 0.5,0.5,0.5\n"
                      "    a single integer: use the location of a sink "
                           "particle with the given index as the center"
                     )
    args.add_argument("-l", "--los", type=float, nargs=3,
                      help="The line of sight vector, usually the face-on "
                           "vector of the disk. When this is set, will plot a "
                           "face-on and edge view that are perpendicular to "
                           "each other."
                      )
    args.add_argument("--no-edgeon", action="store_true",
                      help="Turn off plotting edge-on view when los is set")
    args.add_argument("-w", "--width", default='1',
                      help="The width of the view. Examples: '1', '1000,AU'. Default: '1'")
    args.add_argument("-f", "--fields", default='den',
                      help="The fields to plot. Examples: 'den', 'den,temp'. Default: 'den'")
    args.add_argument("-t", "--to", default='./projections',
                      help="The destination directory. Default: "
                           "'./projections'")
    args.add_argument("-k", "--kinds", default='slc,prj',
                      help="Plot types, either 'slc', 'prj', or 'slc,"
                           "prj' (default)")
    args.add_argument("-s", "--sink", action="store_true",
                      help="Turn on overplotting sink particles")
    args.add_argument("--mass-lim", type=float, nargs=2,
                      help="Colormap limits (in Msun) of the sink particles")
    args.add_argument("-o", "--overwrite", action="store_true",
                      help="Turn on overwritting existing figures. If left "
                           "off (default), will skip existing files.")
    args.add_argument("--overwrite-cache", action="store_true",
                      help="Turn on overwritting cache files used by ytfast")
    args.add_argument("--hide-axes", action="store_true",
                      help="Toggle hide axes")
    args.add_argument("-a", "--annotate-scale", action="store_true",
                      help="Toggle annotate scale")
    args.add_argument("--scale", help="Coeff and unit of annotate_scale")
    args.add_argument("--no-ytfast", action="store_true",
                      help="Turn off using ytfast to speedup projection/slice plot")
    # args.add_argument("-p", "--params", type=dict, default={},
    #                   help="A dictionary of extra parameters")
    args.add_argument("--den-zlim", type=float, nargs=2,
                      help="zlim of density (in cm-3)")
    args.add_argument("--T-zlim", type=float, nargs=2,
                      help="zlim of temperature (in K)")
    args.add_argument("--xHII-zlim", type=float, nargs=2,
                      help="zlim of xHII")
    args.add_argument("--dry-run", action="store_true",
                      help="Toggle dry run: making one figure only and store it in local dierctory")
    args.add_argument("--inzoombox", action="store_true",
                      help="with center=integer, use sink particles in zoombox only.")
    args.add_argument("--rise", help="raise the slice plot by percent of the box width")
    return args.parse_args()


def main(args):
    """
    Main function of plot_projection

    """

    # put imports inside main() to make -h run faster
    import yt
    import numpy as np
    import matplotlib.pyplot as plt
    from glob import glob
    from ramtools import ytfast, Ramses, plotutils, ramses, utilities as ut

    try:
        plt.style.use(['science', 'no-latex'])
    except:
        pass

    r = Ramses(args.jobdir)
    zoomc = r.read_zoom_center()
    zoomr = r.read_zoom_radius()
    if args.outs == 'all':
        outs = r.get_all_outputs()
    else:
        outs = parse_outs(args.outs)
        # outs = []
        # for par in args.outs.split(','):
        #     if '-' in par:
        #         splits = [int(i) for i in par.split('-')]
        #         if len(splits) == 2:
        #             outi, outf = splits
        #             outs += list(range(outi, outf + 1))
        #         elif len(splits) == 3:
        #             outi, outf, diff = splits
        #             outs += list(range(outi, outf + 1, diff))
        #     else:
        #         outs += [int(par)]
    if args.rise is not None:
        rises = parse_outs(args.rise)
    use_sink_as_center = False
    if args.center == 'c':
        center = [0.5, 0.5, 0.5]
    elif args.center == 'zoomc':    # use zoom center
        nmls = sorted(glob(f"{args.jobdir}/*.nml"))
        if len(nmls) == 0:
            print(f"Failed to load a namelist file. Is {args.jobdir} a valid job directory?")
            return
        nml = nmls[0]
        # print(f"Reading center from namelist file {nml}")
        center = ut.read_zoom_center(nml)
    elif ',' in args.center:
        center = [float(i) for i in args.center.split(',')]
    else:
        use_sink_as_center = True
        sink_center = int(args.center)
    if 'zoomr' in args.width:
        nmls = sorted(glob(f"{args.jobdir}/*.nml"))
        if len(nmls) == 0:
            print(f"Failed to load a namelist file. Is {args.jobdir} a valid job directory?")
            return
        nml = nmls[0]
        # print(f"Reading width from namelist file {nml}")
        idx = -1
        if len(args.width) > 5:
            idx = int(args.width[5:])
        width = ut.read_zoom_radius(nml, idx) * 2
    elif ',' in args.width:
        p1, p2 = args.width.split(',')
        width = (float(p1), p2)
    else:
        width = float(args.width)
    os.makedirs(args.to, exist_ok=1)
    axes = None
    if args.los is None:
        axes = args.axes.split(',')
    else:
        if args.no_edgeon:
            axes = ["face"]
        else:
            axes = ["face", "edge"]
        face = np.array(args.los)
        right = np.cross([0, 0, 1], face)
        left = -1. * right
        dires = {"face": [face, left],
                 "edge": [right, face]}
    for out in outs:
        if not r.exist(out):
            print(f"Skipping frame {out}")
            continue
        ds = r.load_ds(out)
        width = ramses.to_boxlen(width, ds)
        if use_sink_as_center:
            try:
                pos = r.get_sink_positions(out) / r.boxlen
                if args.inzoombox:
                    inside = np.max(pos - zoomc, axis=1) <= zoomr
                    if np.sum(inside) == 0:
                        print(f"No sink particles inside zoombox in frame {out}")
                        continue
                    center = pos[inside][sink_center]
                else:
                    center = pos[sink_center]
                # center = r.get_sink_positions(out)[sink_center] / r.boxlen
            except FileNotFoundError:
                continue
            except ramses.NoSinkParticle:
                print(f"No sink particle found in out {out}.")
                continue

        for field in args.fields.split(','):
            if field == "den":
                thefield = ("gas", "density")
            elif field in ["tem", "temp"]:
                thefield = ("gas", "temperature")
            elif field == "grid_level":
                thefield = ("index", field)
            else:
                thefield = ("gas", field)
            for kind in args.kinds.split(','):
                for axis in axes:

                    # rise slices
                    if args.rise and kind == 'slc':
                        assert axis in 'xyz'
                        if axis == 'x':
                            centers = [[center[0] + width * (i - 50) / 100, center[1], center[2]] for i in rises]
                        elif axis == 'y':
                            centers = [[center[0], center[1] + width * (i - 50) / 100, center[2]] for i in rises]
                        elif axis == 'z':
                            centers = [[center[0], center[1], center[2] + width * (i - 50) / 100] for i in rises]
                    else:
                        rises = [-1]
                        centers = [center]

                    # print(center)
                    # print(centers)
                    # return

                    for ccount, center in zip(rises, centers):
                        if ccount >= 0:
                            fo = f"{kind}-{axis}-{field}-out{out}-rise{ccount}.png"
                        else:
                            fo = f"{kind}-{axis}-{field}-out{out}.png"
                        if (not args.overwrite) and os.path.exists(os.path.join(args.to, fo)):
                            print(f"{args.to}/{fo} exists. Skipping")
                            continue
                        if axis in ['face', 'edge']:
                            los = dires[axis][0]
                            north = dires[axis][1]
                        print("Plotting", fo)
                        if kind == 'slc':
                            if axis in ['x', 'y', 'z']:
                                # if args.no_ytfast:
                                # do not use ytfast.SlicePlot
                                if 1:
                                    p = yt.SlicePlot(ds, axis, thefield, center=center, width=width)
                                else:
                                    p = ytfast.SlicePlot(ds, axis, thefield, center=center, width=width,
                                                         force_redo=args.overwrite_cache)
                            else:
                                p = yt.OffAxisSlicePlot(
                                    ds, los, thefield, center=center,
                                    width=width, north_vector=north)
                        elif kind == 'prj':
                            if axis in ['x', 'y', 'z']:
                                if args.no_ytfast:
                                    p = yt.ProjectionPlot(ds, axis, thefield, center=center, width=width,
                                                          weight_field=('gas', 'density'),
                                                          # max_level=10,
                                                          )
                                else:
                                    try:
                                        p = ytfast.ProjectionPlot(ds, axis, thefield, center=center, width=width,
                                                                  weight_field=('gas', 'density'),
                                                                  force_redo=args.overwrite_cache)
                                    except yt.utilities.exceptions.YTPixelizeError:
                                        p = yt.ProjectionPlot(ds, axis, thefield, center=center, width=width,
                                                              weight_field=('gas', 'density'))
                            else:
                                p = yt.OffAxisProjectionPlot(
                                    ds, los, thefield, center=center, width=width,
                                    weight_field=('gas', 'density'), #max_level=l_max,
                                    north_vector=north)
                        if field in ['den', 'density']:
                            plotutils.den_setup(p)
                            #p.set_colorbar_label(thefield, r"log n [cm$^{-3}$]")
                        # if 'zlim' in args.params:
                        #     if field in args.params['zlim']:
                        #         p.set_zlim(thefield, *args.params['zlim'][field])
                        if thefield[1] == "density" and args.den_zlim is not None:
                            p.set_zlim(thefield, *args.den_zlim)
                        elif thefield[1] == "temperature" and args.T_zlim is not None:
                            p.set_zlim(thefield, *args.T_zlim)
                        elif thefield[1] == "xHII" and args.xHII_zlim is not None:
                            p.set_zlim(thefield, *args.xHII_zlim)
                        elif thefield[1] == "grid_level":
                            # p.set_cmap(thefield, "tab10")
                            p.set_cmap(thefield, "tab20")
                            p.set_log(thefield, False)
                            # p.set_zlim(thefield, 3.5, 13.5)
                            p.set_zlim(thefield, -0.5, 19.5)
                        # overplot sink particles
                        if args.sink:
                            is_id = False
                            lims = [0.1, 10]
                            if args.mass_lim is not None:
                                lims = args.mass_lim
                            r.overplot_sink_with_id(
                                p, out, center, width/2, is_id=is_id,
                                zorder='mass', withedge=1, lims=lims)
                        # add a rule bar
                        # if args.annotate_scale:
                        #     # p.annotate_scale(max_frac=0.3, min_frac=0.08)
                        #     if args.scale is not None:
                        #         coeff, unit = float(args.scale.split(',')[0]), args.scale.split(',')[1]
                        #         p.annotate_scale(coeff=coeff, unit=unit)
                        #     else:
                        #         p.annotate_scale(max_frac=0.4, min_frac=0.15, )
                        p.set_figure_size(6)
                        if args.hide_axes:
                            # p.axes.get_xaxis().set_visible(False)
                            # p.axes.get_yaxis().set_visible(False)
                            p.hide_axes()
                            p.set_axes_unit('pc')
                        f = p.export_to_mpl_figure((1,1))
                        if field in ['den', 'density']:
                            cb = f.axes[1]
                            yticks = cb.get_yticks()
                            lbs = [str(int(log10(x))) for x in yticks]
                            # cb.set_yticklabels(['3', '4', '5', '6', '7', '8', '9'])
                            cb.set_yticklabels(lbs)
                            cb.set_ylabel(r"$\log$ density (cm$^{-3}$)")

                        if args.hide_axes and args.annotate_scale:
                            # p.annotate_scale(max_frac=0.3, min_frac=0.08)
                            if args.scale is not None:
                                coeff_str, unit = args.scale.split(',')
                                coeff = float(coeff_str)
                                assert args.hide_axes, "use scale bar only when hide_axes, otherwise the " \
                                                       "length of the scale bar is not corrrect"
                                leng = ramses.to_boxlen((coeff, unit), ds) / ramses.to_boxlen((1, 'pc'), ds)
                                label = f"{coeff_str} {unit}"
                                plotutils.add_scalebar(f.axes[0], leng, label=label, right=0.94,
                                            fontsize="large")
                                # p.annotate_scale(coeff=coeff, unit=unit)
                            else:
                                pass
                                # p.annotate_scale(max_frac=0.4, min_frac=0.15, )
                        if args.dry_run:
                            f.savefig(fo, dpi=300)
                            return
                        f.savefig(os.path.join(args.to, fo), dpi=300)
                        print(f"{args.to}/{fo} saved")
                        plt.close('all')
                        del p
                        # p.save((args.to, fo), mpl_kwargs={"dpi": 300})
    return



if __name__ == '__main__':
    sys.exit(main(get_args()))
